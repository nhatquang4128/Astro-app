"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuizInput = exports.getDerivedIndex = exports.getWordArrayForExternalMethod = exports.getWordStringForExternalMethod = exports.getPreviousValidIndex = exports.getNextValidIndex = exports.getSmartChunkedArray = exports.transformStringWordStructureToSArr = exports.transformWordStructureToString = exports.transformWordStructureToTemplateArray = void 0;
const React = __importStar(require("react"));
const react_1 = require("react");
const react_native_gesture_handler_1 = require("react-native-gesture-handler");
const react_native_1 = require("react-native");
const lodash_chunk_1 = __importDefault(require("lodash.chunk"));
const DEFAULT_PROPS = {
    autoFocus: true,
    maxBoxesPerLine: 0,
    lineBreakOnSpace: false,
    borderColor: '#BBBBBB',
    backgroundColor: 'transparent',
    textColor: '#000000',
    size: 'medium'
};
const getSizeRelatedProps = (size) => {
    switch (size) {
        case 'medium':
        default:
            return {
                width: 26,
                height: 34,
                borderRadius: 7,
                marginLeft: 1,
                marginRight: 1
            };
        case 'small':
            return {
                width: 22,
                height: 28,
                borderRadius: 5,
                marginLeft: 1,
                marginRight: 1
            };
        case 'large':
            return {
                width: 30,
                height: 38,
                borderRadius: 8,
                marginLeft: 1,
                marginRight: 1
            };
    }
};
const transformWordStructureToTemplateArray = (wordStructure) => {
    return wordStructure.map((singleLetter) => {
        if (singleLetter) {
            return '';
        }
        else {
            return false;
        }
    });
};
exports.transformWordStructureToTemplateArray = transformWordStructureToTemplateArray;
const transformWordStructureToString = (wordStructure) => {
    return wordStructure.map((singleLetter) => {
        if (singleLetter) {
            return 'L';
        }
        else {
            return 'S';
        }
    }).join('');
};
exports.transformWordStructureToString = transformWordStructureToString;
const transformStringWordStructureToSArr = (wordStructureAsString) => {
    return wordStructureAsString.map((singleBlock) => {
        const singleBlockAsArr = singleBlock.split('');
        return singleBlockAsArr.map((singleLetter) => (singleLetter === 'L' ? true : false));
    });
};
exports.transformStringWordStructureToSArr = transformStringWordStructureToSArr;
const getSmartChunkedArray = (wordStructure, lineBreakOnSpace, maxBoxesPerLine) => {
    if (maxBoxesPerLine <= 0 && !lineBreakOnSpace) {
        return [wordStructure];
    }
    if (maxBoxesPerLine > 0 && !lineBreakOnSpace) {
        return lodash_chunk_1.default(wordStructure, maxBoxesPerLine);
    }
    // If we are here it means that lineBreakOnSpace is true
    // other then creating chunk for lines, we still take into account maxBoxesPerLine
    // and split the line when needed
    const wordStructureAsString = exports.transformWordStructureToString(wordStructure);
    const spaceChunks = wordStructureAsString.split('S');
    const spaceChunksWithSpaceRow = [];
    spaceChunks.forEach((spaceChunk, index) => {
        spaceChunksWithSpaceRow.push(spaceChunk);
        if (index < spaceChunks.length - 1) {
            spaceChunksWithSpaceRow.push('S');
        }
    });
    const processedSpaceChunks = spaceChunksWithSpaceRow.map((singleChunk) => {
        if (singleChunk.length <= maxBoxesPerLine || maxBoxesPerLine === 0) {
            return singleChunk;
        }
        else {
            return lodash_chunk_1.default(singleChunk, maxBoxesPerLine);
        }
    });
    const flattenedArray = [];
    processedSpaceChunks.forEach((singleChunk) => {
        if (Array.isArray(singleChunk)) {
            singleChunk.forEach((nestedChunk) => {
                flattenedArray.push(nestedChunk.join(''));
            });
        }
        else {
            flattenedArray.push(singleChunk);
        }
    });
    const reconstructedArr = exports.transformStringWordStructureToSArr(flattenedArray);
    return reconstructedArr;
};
exports.getSmartChunkedArray = getSmartChunkedArray;
const getNextValidIndex = (wordStructure, currentIndex) => {
    if (currentIndex >= wordStructure.length - 1) {
        return -1;
    }
    if (wordStructure[currentIndex + 1]) {
        return currentIndex + 1;
    }
    return exports.getNextValidIndex(wordStructure, currentIndex + 1);
};
exports.getNextValidIndex = getNextValidIndex;
const getPreviousValidIndex = (wordStructure, currentIndex) => {
    if (currentIndex <= 0) {
        return currentIndex;
    }
    if (wordStructure[currentIndex - 1]) {
        return currentIndex - 1;
    }
    return exports.getPreviousValidIndex(wordStructure, currentIndex - 1);
};
exports.getPreviousValidIndex = getPreviousValidIndex;
const getWordStringForExternalMethod = (newWordArray) => {
    const processedArr = [];
    for (let count = 0; count < newWordArray.length; count++) {
        const currentLetter = newWordArray[count];
        switch (currentLetter) {
            case undefined:
            case false:
                processedArr.push(' ');
                break;
            case true:
                processedArr.push('*'); // this case is here only for extra safety, but it's not supposed to happen
                break;
            case '':
                processedArr.push('');
                break;
            default:
                processedArr.push(currentLetter);
                break;
        }
    }
    return processedArr.join('');
};
exports.getWordStringForExternalMethod = getWordStringForExternalMethod;
const getWordArrayForExternalMethod = (wordStructure, newWordArray) => {
    const wordForExternalMethod = wordStructure.map((singleSlot, index) => {
        if (singleSlot === false) {
            return singleSlot;
        }
        if (newWordArray[index]) {
            return newWordArray[index];
        }
        else {
            return '';
        }
    });
    return wordForExternalMethod;
};
exports.getWordArrayForExternalMethod = getWordArrayForExternalMethod;
const getDerivedIndex = (smartChunkedArray, rowIndex, indexInRow) => {
    if (rowIndex === 0) {
        return indexInRow;
    }
    let previousRowsTotalCount = 0;
    for (let rowCount = 0; rowCount < rowIndex; rowCount++) {
        previousRowsTotalCount = previousRowsTotalCount + smartChunkedArray[rowCount].length;
    }
    return previousRowsTotalCount + indexInRow;
};
exports.getDerivedIndex = getDerivedIndex;
const QuizInput = (props) => {
    const mergedProps = {
        ...DEFAULT_PROPS,
        ...props
    };
    const { wordStructure, autoFocus, maxBoxesPerLine, lineBreakOnSpace, borderColor, backgroundColor, textColor, size, onChange: externalOnChange } = mergedProps;
    const inputsRef = react_1.useRef([]);
    const [activeLetter, setActiveLetter] = react_1.useState(0);
    const [inputContentArray, setInputContentArray] = react_1.useState(exports.transformWordStructureToTemplateArray(wordStructure));
    react_1.useEffect(() => {
        inputsRef.current = inputsRef.current.slice(0, wordStructure.length);
    }, [wordStructure]);
    react_1.useEffect(() => {
        if (autoFocus) {
            inputsRef?.current?.[0]?.focus();
        }
    }, [autoFocus]);
    react_1.useEffect(() => {
        inputsRef?.current?.[activeLetter]?.clear();
        inputsRef?.current?.[activeLetter]?.focus();
    }, [activeLetter]);
    react_1.useEffect(() => {
        const callbackData = {
            wordArray: inputContentArray,
            wordString: exports.getWordStringForExternalMethod(inputContentArray)
        };
        externalOnChange(callbackData);
    }, [inputContentArray, externalOnChange]);
    const sizeRelatedProps = getSizeRelatedProps(size);
    const individualCharsInputStyles = react_native_1.StyleSheet.create({
        // this is the View wrapping all Scrollviews
        inputsWrapper: {
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'space-around'
        },
        // this is the ScrollView wrapper
        scrollViewWrapper: {
            flexGrow: 0
        },
        // this is the ScrollView content
        inputWrapper: {
            display: 'flex',
            flexDirection: 'row',
            marginBottom: 10,
            justifyContent: 'center'
        },
        singleInput: {
            ...sizeRelatedProps,
            backgroundColor,
            color: textColor,
            borderBottomWidth: 1,
            borderBottomColor: borderColor,
            borderTopWidth: 1,
            borderTopColor: borderColor,
            borderLeftWidth: 1,
            borderLeftColor: borderColor,
            borderRightWidth: 1,
            borderRightColor: borderColor,
            marginRight: 1,
            textAlign: 'center',
            paddingTop: 0,
            paddingBottom: 0
        },
        spacer: {
            width: 20
        }
    });
    const onTextChange = (letter, index) => {
        const newInputContent = [...inputContentArray];
        newInputContent.splice(index, 1, letter);
        setInputContentArray(newInputContent);
    };
    const onLetterChange = (event, index) => {
        const { nativeEvent } = event;
        if (nativeEvent.key === 'Backspace') {
            if (!inputContentArray[index]) {
                const prevIndex = exports.getPreviousValidIndex(wordStructure, index);
                setActiveLetter(prevIndex);
                onTextChange('', prevIndex);
            }
            else {
                onTextChange('', index);
            }
        }
        else {
            const nextIndex = exports.getNextValidIndex(wordStructure, index);
            setActiveLetter(nextIndex);
        }
    };
    const wordStructureRows = exports.getSmartChunkedArray(wordStructure, lineBreakOnSpace, maxBoxesPerLine);
    return (<react_native_1.View style={individualCharsInputStyles.inputsWrapper}>
            {wordStructureRows.map((singleRow, rowIndex) => {
            return (<react_native_gesture_handler_1.ScrollView style={individualCharsInputStyles.scrollViewWrapper} keyboardShouldPersistTaps='never' key={rowIndex} contentContainerStyle={individualCharsInputStyles.inputWrapper}>

                        {singleRow.map((singleInput, indexInRow) => {
                    const derivedIndex = exports.getDerivedIndex(wordStructureRows, rowIndex, indexInRow);
                    if (singleInput) {
                        return (<react_native_gesture_handler_1.TextInput key={derivedIndex.toString()} ref={(el) => { inputsRef.current[derivedIndex] = el; }} style={individualCharsInputStyles.singleInput} maxLength={1} onKeyPress={(event) => onLetterChange(event, derivedIndex)} onChangeText={(letter) => onTextChange(letter, derivedIndex)} autoCorrect={false} autoCompleteType={'off'} autoCapitalize={'characters'}/>);
                    }
                    else {
                        return (<react_native_1.View key={derivedIndex.toString()} style={individualCharsInputStyles.spacer}/>);
                    }
                })}
                    </react_native_gesture_handler_1.ScrollView>);
        })}
        </react_native_1.View>);
};
exports.QuizInput = QuizInput;
exports.default = react_native_1.NativeModules.RNQuizInputModule;
//# sourceMappingURL=index.js.map